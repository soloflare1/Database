### üîπ What is `OFFSET`?

* It **skips rows** before starting to return the result set.
* Works **with** `LIMIT` to implement **pagination**.
* Pagination = Dividing large result sets into smaller "pages" of data.
* LIMIT page_size OFFSET (page_number - 1) * page_size
* LIMIT n OFFSET (x - 1) * n


```sql
SELECT * FROM students
ORDER BY marks DESC
LIMIT 5 
OFFSET 5;
```

> Show students ranked **6th to 10th** by marks.

---

### üìò Key Concepts

| Concept            | Description                                                              |
| ------------------ | ------------------------------------------------------------------------ |
| `LIMIT n`          | Return only `n` rows                                                     |
| `OFFSET m`         | Skip the **first `m` rows**                                              |
| `ORDER BY`         | Required if you want predictable order                                   |
| `LIMIT + OFFSET`   | Used to build **pages** of results (e.g., page 2 = `OFFSET 10 LIMIT 10`) |
| Without `ORDER BY` | The rows returned may vary ‚Äî no guarantee on order                       |

---

## üîç When to Use

| Use Case                  | Use `OFFSET`?     | Why?                             |
| ------------------------- | ----------------- | -------------------------------- |
| Pagination (next 10 rows) | ‚úÖ Yes             | To jump ahead in result set      |
| Top-N results             | ‚ùå No              | Just use `LIMIT`                 |
| Skip low-priority rows    | ‚úÖ Yes             | Ignore first N, fetch next M     |
| Predictable order needed  | ‚úÖ With `ORDER BY` | Ensures OFFSET behaves correctly |

---

## üß† Performance Tip

* `OFFSET` **still scans skipped rows** ‚Äî it just doesn't return them.
* On **large tables**, deep offsets (like `OFFSET 10000`) can be slow.
* Use **key-based pagination** (e.g., `WHERE id > last_seen_id`) for better performance.

---

## ‚úÖ Common Pagination Pattern

```sql
-- Page 1 (first 10)
SELECT * 
FROM students 
ORDER BY id 
LIMIT 10 
OFFSET 0;

-- Page 2 (next 10)
SELECT * 
FROM students 
ORDER BY id 
LIMIT 10 
OFFSET 10;
```

---
## Example: You want Page 3, and each page has 5 results.
```sql
SELECT * FROM students
ORDER BY marks DESC
LIMIT 5 
OFFSET 10    OFFSET (3 - 1) * 5;  --or, OFFSET (3 - 1) * 5; 

```
Nice! This is a classic **pagination**-style question.

Let‚Äôs break it down **step by step** ‚Äî and I‚Äôll guide you to write the query:

---

## üîé ‚ÄúShow the 4th to 6th highest scoring students.‚Äù

That means:

* **Sort by marks (high to low)** ‚úÖ
* **Skip top 3** (1st, 2nd, 3rd highest) ‚úÖ
* **Show next 3** (4th, 5th, 6th) ‚úÖ

---

## üß† Which SQL tools do we need?

* `ORDER BY marks DESC` ‚Üí to get highest first
* `LIMIT 3` ‚Üí to get 3 results
* `OFFSET 3` ‚Üí to skip the first 3

---
 
```sql
SELECT name, marks
FROM students
ORDER BY marks desc
LIMIT 3
OFFSET 3;
```
